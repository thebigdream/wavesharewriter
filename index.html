<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="description" content="Waveshare NFC E-Paper Checkerboard Demo">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Waveshare Writer</title>
</head>
<body>
<h1>Waveshare NFC E-Paper Checkerboard Demo</h1>

<button id="scanButton">Scan</button>
<button id="writeButton">Write Checkerboard</button>
<button id="makeReadOnlyButton">Make Read-Only</button>

<pre id="log"></pre>

<script>
const log = (...args) => {
  document.getElementById('log').textContent += args.join(' ') + '\n';
};

// Display size
const WIDTH = 640;
const HEIGHT = 384;

// Generate 1-bit checkerboard
function generateCheckerboard() {
  const bytesPerRow = WIDTH / 8;
  const buffer = new Uint8Array(bytesPerRow * HEIGHT);

  for (let y = 0; y < HEIGHT; y++) {
    for (let xByte = 0; xByte < bytesPerRow; xByte++) {
      let byte = 0;
      for (let bit = 0; bit < 8; bit++) {
        const x = xByte * 8 + bit;
        const isBlack = ((Math.floor(x / 8) + Math.floor(y / 8)) % 2) === 0;
        if (isBlack) byte |= (1 << (7 - bit));
      }
      buffer[y * bytesPerRow + xByte] = byte;
    }
  }
  return buffer;
}

// Split into 256-byte blocks and prepend header + metadata
function createBlocks(pixelBuffer) {
  const BLOCK_SIZE = 256;
  const HEADER_SIZE = 16;
  const FILENAME = 'generic_640x384.bin';
  const blocks = [];
  const totalBlocks = Math.ceil(pixelBuffer.length / (BLOCK_SIZE - HEADER_SIZE));

  for (let i = 0; i < totalBlocks; i++) {
    const start = i * (BLOCK_SIZE - HEADER_SIZE);
    const end = Math.min(start + (BLOCK_SIZE - HEADER_SIZE), pixelBuffer.length);
    const chunk = pixelBuffer.slice(start, end);

    const block = new Uint8Array(BLOCK_SIZE);
    // Magic header
    block[0] = 0x57;
    block[1] = 0x53;
    block[2] = 0x44;
    block[3] = 0x5A;

    // Metadata
    // Filename at offset 0x06
    for (let j = 0; j < FILENAME.length && (6+j)<HEADER_SIZE; j++) {
      block[6+j] = FILENAME.charCodeAt(j);
    }

    // Minimal checksum (XOR of pixel bytes)
    let checksum = 0;
    for (let b of chunk) checksum ^= b;
    block[0x10] = checksum;

    // Pixel data
    block.set(chunk, HEADER_SIZE);

    blocks.push(block);
  }
  return blocks;
}

// Write each block sequentially
async function writeBlocksNFC(blocks) {
  try {
    const ndef = new NDEFReader();
    log("> Waiting for NFC scan...");
    await ndef.scan();
    log("> Scan started");

    for (let i = 0; i < blocks.length; i++) {
      await ndef.write({
        records: [{
          recordType: "mime",
          mediaType: "application/octet-stream",
          data: blocks[i]
        }]
      });
      log(`> Block ${i+1}/${blocks.length} sent`);
      await new Promise(r => setTimeout(r, 50));
    }

    log("> All blocks sent!");
  } catch (error) {
    log("Argh! " + error);
  }
}

// Button handlers
document.getElementById('scanButton').addEventListener('click', async () => {
  try {
    const ndef = new NDEFReader();
    await ndef.scan();
    log("> Scan started");

    ndef.addEventListener("readingerror", () => log("Cannot read NFC tag."));
    ndef.addEventListener("reading", ({ message, serialNumber }) => {
      log(`> Serial Number: ${serialNumber}`);
      log(`> Records: ${message.records.length}`);
    });
  } catch (error) {
    log("Argh! " + error);
  }
});

document.getElementById('writeButton').addEventListener('click', async () => {
  const pixels = generateCheckerboard();
  const blocks = createBlocks(pixels);
  await writeBlocksNFC(blocks);
});

document.getElementById('makeReadOnlyButton').addEventListener('click', async () => {
  try {
    const ndef = new NDEFReader();
    await ndef.makeReadOnly();
    log("> NFC tag has been made permanently read-only");
  } catch (error) {
    log("Argh! " + error);
  }
});
</script>
</body>
</html>
